// node_modules/fs/index.js

function getBridge() {
    if (typeof fsBridge !== 'undefined' && fsBridge) return fsBridge;   // realm-local
    // Optional: allow an engine fallback if you still publish engine-wide
    if (typeof Polyglot !== 'undefined' && typeof Polyglot.import === 'function') {
        try { const b = Polyglot.import('fsBridge'); if (b) return b; } catch {}
    }
    throw new Error("fsBridge not available (inject via Polyglot before require())");
}

// ---- Sync API ----
function readFileSync(path, options) {
    const enc = normalizeEncoding(options);
    if (enc && enc !== 'utf8') throw new Error("fs shim supports only 'utf8' encoding");
    return getBridge().readFileUtf8(String(path));
}

function writeFileSync(path, data, options) {
    const enc = normalizeEncoding(options);
    if (enc && enc !== 'utf8') throw new Error("fs shim supports only 'utf8' encoding");
    if (typeof data !== 'string') data = String(data);
    getBridge().writeFileUtf8(String(path), data);
}

function existsSync(path) {
    try { return !!getBridge().exists(String(path)); }
    catch { return false; }
}

function readdirSync(path, options) {
    const withFileTypes = options && options.withFileTypes;
    if (withFileTypes) {
        const jsArray = getBridge().readdirWithFileTypes(String(path));

        // Convert JSArray to native JavaScript array
        const result = [];
        if (jsArray) {
            const length = typeof jsArray.length === 'function' ? jsArray.length() : jsArray.length;
            for (let i = 0; i < length; i++) {
                result.push(jsArray.get(i));
            }
        }
        return result;
    }
    const jsArray = getBridge().readdir(String(path));
    // Convert JSArray to native JavaScript array
    const result = [];
    if (jsArray) {
        const length = typeof jsArray.length === 'function' ? jsArray.length() : jsArray.length;
        for (let i = 0; i < length; i++) {
            result.push(jsArray.get(i));
        }
    }
    return result;
}

function statSync(path) {
    const s = getBridge().stat(String(path));
    return {
        size: s.size,
        mtimeMs: s.mtimeMs,
        isFile: () => !!s.isFile,
        isDirectory: () => !!s.isDir,
    };
}

// ---- Minimal async wrappers (Promise-based) ----
function readFile(path, options, cb) {
    const enc = normalizeEncoding(options);
    const run = () => readFileSync(path, enc || 'utf8');
    if (typeof cb === 'function') { try { cb(null, run()); } catch (e) { cb(e); } return; }
    return new Promise((res, rej) => { try { res(run()); } catch (e) { rej(e); } });
}

function writeFile(path, data, options, cb) {
    const enc = normalizeEncoding(options);
    const run = () => writeFileSync(path, data, enc || 'utf8');
    if (typeof cb === 'function') { try { cb(null, run()); } catch (e) { cb(e); } return; }
    return new Promise((res, rej) => { try { res(run()); } catch (e) { rej(e); } });
}

function readdir(path, options, cb) {
    // Handle parameter overloading: readdir(path, callback) or readdir(path, options, callback)
    if (typeof options === 'function') {
        cb = options;
        options = {};
    }
    if (!options) options = {};

    const run = () => readdirSync(path, options);
    if (typeof cb === 'function') {
        try {
            cb(null, run());
        } catch (e) {
            cb(e);
        }
        return;
    }
    return new Promise((res, rej) => {
        try {
            res(run());
        } catch (e) {
            rej(e);
        }
    });
}

function normalizeEncoding(opt) {
    if (!opt) return 'utf8';
    if (typeof opt === 'string') return opt.toLowerCase();
    if (typeof opt === 'object' && opt.encoding) return String(opt.encoding).toLowerCase();
    return 'utf8';
}

// Promises API (modern async/await support)
const promises = {
    readFile: (path, options) => {
        return new Promise((res, rej) => {
            readFile(path, options, (err, data) => {
                if (err) rej(err);
                else res(data);
            });
        });
    },

    writeFile: (path, data, options) => {
        return new Promise((res, rej) => {
            writeFile(path, data, options, (err) => {
                if (err) rej(err);
                else res();
            });
        });
    },

    readdir: (path, options) => {
        return new Promise((res, rej) => {
            try {
                res(readdirSync(path, options));
            } catch (e) {
                rej(e);
            }
        });
    }
};

module.exports = {
    readFileSync, writeFileSync, existsSync, readdirSync, statSync,
    readFile, writeFile, readdir,
    promises
};
